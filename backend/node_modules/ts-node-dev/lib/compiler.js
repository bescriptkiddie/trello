"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCompiler = void 0;
var tsNode = __importStar(require("ts-node"));
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var os_1 = __importDefault(require("os"));
var mkdirp_1 = __importDefault(require("mkdirp"));
var rimraf_1 = __importDefault(require("rimraf"));
var tsconfig_1 = require("tsconfig");
var get_compiled_path_1 = require("./get-compiled-path");
var fixPath = function (p) { return p.replace(/\\/g, '/').replace(/\$/g, '$$$$'); };
var sourceMapSupportPath = require.resolve('source-map-support');
var extensions = ['.ts', '.tsx'];
var empty = function () { };
var cwd = process.cwd();
var compilationInstanceStamp = Math.random().toString().slice(2);
var originalJsHandler = require.extensions['.js'];
// const extHandlers = {}
function hasOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
}
function getCwd(dir, scriptMode, scriptPath) {
    if (scriptMode) {
        if (!scriptPath) {
            console.error('Script mode must be used with a script name, e.g. `ts-node-dev -s <script.ts>`');
            process.exit();
        }
        if (dir) {
            console.error('Script mode cannot be combined with `--dir`');
            process.exit();
        }
        // Use node's own resolution behavior to ensure we follow symlinks.
        // scriptPath may omit file extension or point to a directory with or without package.json.
        // This happens before we are registered, so we tell node's resolver to consider ts, tsx, and jsx files.
        // In extremely rare cases, is is technically possible to resolve the wrong directory,
        // because we do not yet know preferTsExts, jsx, nor allowJs.
        // See also, justification why this will not happen in real-world situations:
        // https://github.com/TypeStrong/ts-node/pull/1009#issuecomment-613017081
        var exts = ['.js', '.jsx', '.ts', '.tsx'];
        var extsTemporarilyInstalled = [];
        for (var _i = 0, exts_1 = exts; _i < exts_1.length; _i++) {
            var ext = exts_1[_i];
            if (!hasOwnProperty(require.extensions, ext)) {
                // tslint:disable-line
                extsTemporarilyInstalled.push(ext);
                require.extensions[ext] = function () { }; // tslint:disable-line
            }
        }
        try {
            return path_1.default.dirname(require.resolve(scriptPath));
        }
        finally {
            for (var _a = 0, extsTemporarilyInstalled_1 = extsTemporarilyInstalled; _a < extsTemporarilyInstalled_1.length; _a++) {
                var ext = extsTemporarilyInstalled_1[_a];
                delete require.extensions[ext]; // tslint:disable-line
            }
        }
    }
    return dir;
}
exports.makeCompiler = function (options, _a) {
    var log = _a.log, restart = _a.restart;
    var service;
    var _errorCompileTimeout;
    var allowJs = false;
    var project = options['project'];
    var tsConfigPath = tsconfig_1.resolveSync(cwd, typeof project === 'string' ? project : undefined) || '';
    var tmpDir = options['cache-directory']
        ? path_1.default.resolve(options['cache-directory'])
        : fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), '.ts-node'));
    var init = function () {
        //const originalJsHandler = require.extensions['.js']
        require.extensions['.ts'] = empty;
        require.extensions['.tsx'] = empty;
        compiler.registerTsNode();
        /* clean up compiled on each new init*/
        rimraf_1.default.sync(compiler.getCompiledDir());
        compiler.createCompiledDir();
        // check if `allowJs` compiler option enable
        // (if it was changed after ts-node registration)
        var allowJsEnabled = require.extensions['.js'] !== originalJsHandler;
        if (allowJsEnabled) {
            allowJs = true;
            //require.extensions['.js'] = originalJsHandler
            extensions.push('.js');
        }
        compiler.writeChildHookFile(options);
    };
    var compiler = {
        tsConfigPath: tsConfigPath,
        init: init,
        getCompilationId: function () {
            return compilationInstanceStamp;
        },
        createCompiledDir: function () {
            var compiledDir = compiler.getCompiledDir();
            if (!fs_1.default.existsSync(compiledDir)) {
                mkdirp_1.default.sync(compiler.getCompiledDir());
            }
        },
        getCompiledDir: function () {
            return path_1.default.join(tmpDir, 'compiled').replace(/\\/g, '/');
        },
        getCompileReqFilePath: function () {
            return path_1.default.join(compiler.getCompiledDir(), compiler.getCompilationId() + '.req');
        },
        getCompilerReadyFilePath: function () {
            return path_1.default
                .join(os_1.default.tmpdir(), 'ts-node-dev-ready-' + compilationInstanceStamp)
                .replace(/\\/g, '/');
        },
        getChildHookPath: function () {
            return path_1.default
                .join(os_1.default.tmpdir(), 'ts-node-dev-hook-' + compilationInstanceStamp + '.js')
                .replace(/\\/g, '/');
        },
        writeReadyFile: function () {
            var fileData = fs_1.default.writeFileSync(compiler.getCompilerReadyFilePath(), '');
        },
        writeChildHookFile: function (options) {
            var compileTimeout = parseInt(options['compile-timeout']);
            var getIgnoreVal = function (ignore) {
                var ignoreVal = !ignore || ignore === 'false'
                    ? 'false'
                    : '[' +
                        ignore
                            .split(/,/)
                            .map(function (i) { return i.trim(); })
                            .map(function (ignore) { return 'new RegExp("' + ignore + '")'; })
                            .join(', ') +
                        ']';
                return ignoreVal;
            };
            var varDecl = function (name, value) {
                return "var " + name + " = '" + value + "'";
            };
            var replacements = [
                compileTimeout ? ['10000', compileTimeout.toString()] : null,
                allowJs ? ['allowJs = false', 'allowJs = true'] : null,
                options['prefer-ts-exts']
                    ? ['preferTs = false', 'preferTs = true']
                    : null,
                options['exec-check']
                    ? ['execCheck = false', 'execCheck = true']
                    : null,
                options['exit-child']
                    ? ['exitChild = false', 'exitChild = true']
                    : null,
                options['ignore'] !== undefined
                    ? [
                        'var ignore = [/node_modules/]',
                        'var ignore = ' + getIgnoreVal(options['ignore']),
                    ]
                    : null,
                [
                    varDecl('compilationId', ''),
                    varDecl('compilationId', compiler.getCompilationId()),
                ],
                [
                    varDecl('compiledDir', ''),
                    varDecl('compiledDir', compiler.getCompiledDir()),
                ],
                [
                    './get-compiled-path',
                    fixPath(path_1.default.join(__dirname, 'get-compiled-path')),
                ],
                [
                    varDecl('readyFile', ''),
                    varDecl('readyFile', compiler.getCompilerReadyFilePath()),
                ],
                [
                    varDecl('sourceMapSupportPath', ''),
                    varDecl('sourceMapSupportPath', fixPath(sourceMapSupportPath)),
                ],
                [
                    varDecl('libPath', ''),
                    varDecl('libPath', __dirname.replace(/\\/g, '\\\\')),
                ],
                ['__dirname', '"' + fixPath(__dirname) + '"'],
            ]
                .filter(function (_) { return !!_; })
                .map(function (_) { return _; });
            var fileText = fs_1.default.readFileSync(path_1.default.join(__dirname, 'child-require-hook.js'), 'utf-8');
            var fileData = replacements.reduce(function (text, _a) {
                var what = _a[0], to = _a[1];
                return text.replace(what, to);
            }, fileText);
            fs_1.default.writeFileSync(compiler.getChildHookPath(), fileData);
        },
        clearErrorCompile: function () {
            clearTimeout(_errorCompileTimeout);
        },
        registerTsNode: function () {
            // revert back original handler extensions
            // in case of re-registering
            ;
            ['.js', '.jsx', '.ts', '.tsx'].forEach(function (ext) {
                require.extensions[ext] = originalJsHandler;
            });
            var scriptPath = options._.length
                ? path_1.default.resolve(cwd, options._[0])
                : undefined;
            var DEFAULTS = tsNode.DEFAULTS;
            service = tsNode.register({
                // --dir does not work (it gives a boolean only) so we only check for script-mode
                dir: getCwd(options['dir'], options['script-mode'], scriptPath),
                scope: options['scope'] || DEFAULTS.scope,
                emit: options['emit'] || DEFAULTS.emit,
                files: options['files'] || DEFAULTS.files,
                pretty: options['pretty'] || DEFAULTS.pretty,
                transpileOnly: options['transpile-only'] || DEFAULTS.transpileOnly,
                ignore: options['ignore']
                    ? tsNode.split(options['ignore'])
                    : DEFAULTS.ignore,
                preferTsExts: options['prefer-ts-exts'] || DEFAULTS.preferTsExts,
                logError: options['log-error'] || DEFAULTS.logError,
                project: options['project'],
                skipProject: options['skip-project'],
                skipIgnore: options['skip-ignore'],
                compiler: options['compiler'] || DEFAULTS.compiler,
                compilerHost: options['compiler-host'] || DEFAULTS.compilerHost,
                ignoreDiagnostics: options['ignore-diagnostics']
                    ? tsNode.split(options['ignore-diagnostics'])
                    : DEFAULTS.ignoreDiagnostics,
                compilerOptions: tsNode.parse(options['compiler-options']),
            });
        },
        compileChanged: function (fileName) {
            var ext = path_1.default.extname(fileName);
            if (extensions.indexOf(ext) < 0)
                return;
            try {
                var code = fs_1.default.readFileSync(fileName, 'utf-8');
                compiler.compile({
                    code: code,
                    compile: fileName,
                    compiledPath: get_compiled_path_1.getCompiledPath(code, fileName, compiler.getCompiledDir()),
                });
            }
            catch (e) {
                console.error(e);
            }
        },
        compile: function (params) {
            var fileName = params.compile;
            var code = fs_1.default.readFileSync(fileName, 'utf-8');
            var compiledPath = params.compiledPath;
            function writeCompiled(code, fileName) {
                fs_1.default.writeFileSync(compiledPath, code);
                fs_1.default.writeFileSync(compiledPath + '.done', '');
            }
            if (fs_1.default.existsSync(compiledPath)) {
                return;
            }
            var starTime = new Date().getTime();
            var m = {
                _compile: writeCompiled,
            };
            var _compile = function () {
                var ext = path_1.default.extname(fileName);
                var extHandler = require.extensions[ext];
                extHandler(m, fileName);
                m._compile(code, fileName);
                log.debug(fileName, 'compiled in', new Date().getTime() - starTime, 'ms');
            };
            try {
                _compile();
            }
            catch (e) {
                console.log('Compilation error in', fileName);
                var errorCode = 'throw ' + 'new Error(' + JSON.stringify(e.message) + ')' + ';';
                writeCompiled(errorCode);
                // reinitialize ts-node compilation to clean up state after error
                // without timeout in causes cases error not be printed out
                setTimeout(function () {
                    compiler.registerTsNode();
                }, 0);
                if (!options['error-recompile']) {
                    return;
                }
                var timeoutMs_1 = parseInt(process.env.TS_NODE_DEV_ERROR_RECOMPILE_TIMEOUT || '0') ||
                    5000;
                var errorHandler_1 = function () {
                    clearTimeout(_errorCompileTimeout);
                    _errorCompileTimeout = setTimeout(function () {
                        try {
                            _compile();
                            restart(fileName);
                        }
                        catch (e) {
                            compiler.registerTsNode();
                            errorHandler_1();
                        }
                    }, timeoutMs_1);
                };
                errorHandler_1();
            }
        },
    };
    return compiler;
};
